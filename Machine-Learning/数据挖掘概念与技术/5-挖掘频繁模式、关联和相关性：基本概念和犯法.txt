频繁项集（frequent item sets）是经常出现在一块儿的物品的集合，关联规则（association rules）暗示两种物品之间可能存在很强的关系。
1、关联规则被认为是有趣的，满足最小支持度阀值和最小置信度阀值。
项的集合称为项集，包含k个项项集成为k项集，buys(X,"computer")=>buys(x,"software")[support=1%,confidence=50%]就是2项集
此外，confidence(a=>b)=P(b|a)=support(a∪b)/support(a),因此关联规则的问题可以归结为挖掘频繁项集


2、如果项集的相对支持度满足预定义的最小支持度阀值，则是频繁项集
频繁项集的主要挑战是：如果一个项集是频繁的，那么其子集也是频繁的。(更常用的说法：如果一个项集是非频繁的，那么它的所有超集也是非频繁的)



3、频繁项集挖掘方法：
3.1、Apriori算法：为布尔关联规则挖掘频繁项集的原创性算法

3.2、Apriori算法使用逐层搜索的迭代方法，其中k项集用于探索k+1项集。首先，扫描数据库，累计每个项的计数，并计算满足最小支持度的项，找出频繁1项集的集合。该集合即为L1。然后使用L1找出2项集的集合L2，一直这样下去直到不能再找到频繁K项集

3.3、为了提高频繁项集逐层产生的效率，需要先验性质用于压缩搜索空间
     先验性质：频繁项集的所有非空子集也一定是频繁的
Apriori算法的两个输入参数分别是最小支持度和数据集。该算法首先会生成所有单个元素的项集列表。接着扫描数据集来查看哪些项集满足最小支持度要求，那些不满足最小支持度的集合会被去掉。然后，对剩下来的集合进行组合以生成包含两个元素的项集。接下来，再重新扫描交易记录，去掉不满足最小支持度的项集。该过程重复进行直到所有项集都被去掉。



4、挖掘频繁项集的模式增长方法FP-growth
首先将代表频繁项集的数据库压缩到一棵频繁模式树，该树仍保留项集的关联信息；然后将这种压缩后的数据库划分为一组条件数据库，每个数据库关联一个频繁项或模式段，并分别挖掘每个条件数据库。这种方式可以显著压缩被搜索数据集的大小。

优点：一般要快于Apriori。
缺点：实现比较困难，在某些数据集上性能会下降。
适用数据类型：离散型数据。

Apriori算法和FP-growth算法都是TID项集格式的事务集中挖掘频繁模式；也称为水平数据格式

还有一种方法是：垂直数据格式挖掘频繁项集



5、哪些模式是有趣的：模式评估方法
5.1、强规则不一定是有趣的
10000个事务中，6000个是购买计算机游戏，7500个是购买录像，4000个是同时购买计算机游戏和录像，使用最小支持度30和最小置信度60，
计算会发现支持度40,置信度是66，但实际上购买录像的概率是75，计算机游戏和录像是负相关的，因此这里会得出错误的决定

5.2、最好加入相关分析：从关联分析到相关分析.A=>B[support,confidence,correlation]
提升度lift(A,B)=p(A∪B)/P(A)P(B)，如果提升度小于1，负相关；等于1，独立；大于1，正相关
因此使用5.1中的例子，可以发现lift(计算机，游戏)=0.4/0.6*0.75=0.89,说明计算机和录像负相关

5.3、使用卡方检验
卡方=∑((观测值-期望值)²/期望值),可以查看期望值

5.4、模式评估度量比较：全置信度、最大置信度、Kulczynski和余弦
全置信度all_conf(A,B)=sup(A∪B)/max{sup(A),sup(B)}=min{P(A|B),P(B|A)},因此也叫最小置信度
最大置信度=max{P(A|B),P(B|A)}
Kulc=(P(A|B)+P(B|A))/2,也就是两个置信度的均值!!!!!!!!!!!!!!!这个最好
余弦=根号(P(A|B)*P(B|A))











